- "fr = 40e+03; f = linspace(fr - (fr / 10), fr + (fr / 10), 12000); omega = 2*pi .* f;"
- "z_L1 = 400;"
- "z_c = rho * v;"
- "keyMap = caricaStrutturaProprietaMateriali();"
- "selezioneMateriale = obj.App.TabController.getTab('MaterialiTab').getComponent('MenuStrati').Value"
- "props = keyMap(string(selezioneMateriale));"
- "v_l = props(1); rho_l = props(2); z_l = props(3);"
- "a = ( v_l / (2*pi*fr) ) * atan( ( z_c/ z_l ) * ( 1 / tan( (2*pi*fr*(l/2)) / v ) ) );"
- "k = omega/v_l;"
- "s = areaFaccia;"
- "Y = (v_l^2) * rho_l;"
- "L1 = a;"
- "M1_11 = (k .* s .* Y) ./ (1i .* omega .* tan(k .* L1));"
- "M1_12 = (k .* s .* Y) ./ (1i .* omega .* sin(k .* L1));"
- "M1_21 = M1_12;"
- "M1_22 = M1_11;"
- "M1 = {M1_11, M1_12; M1_21, M1_22};"
- "Z_L1 =  z_L1 * areaFaccia;"
- "ZoD = z_c * areaFaccia;"
- "Zeq = M1{1,1} - ( (M1{1,2}.^2) ./ (Z_L1 + M1{1,1}) );"
- "numberOfCeramicPairs = 1;"
- "new_l_c = l / (2 ^ numberOfCeramicPairs);"
- "new_C0 = (2 ^ numberOfCeramicPairs) * C0;"
- "A_couple = calcolaMatriceA(ZoD, omega, v, new_l_c, h33, new_C0);"
- "G = calcolaMatriceG(A_couple, A_couple);"
- "B_couple = calcolaMatriceB(G, Zeq);"
- "[Zin, FTT_pzt, ~] = calcolaFunzioniDiTrasferimento(B_couple, Zeq, Zeq);"
- "FTT_pzt = db2mag(FTT_pzt{1}) .* exp(1j*deg2rad(FTT_pzt{2}));"
- "FTT_mass = ( M1{1,2} .* Z_L1 ) ./ ( M1{1,1}.*Z_L1 + M1{1,1}.^2 - M1{1,2}.^2);"
- "FTT = FTT_pzt .* FTT_mass;"
- "[moduloFTT, faseFTT] = calcolaModuloEFase(FTT, true, true);"
- "FTT = {moduloFTT, faseFTT};"
- "f_iter = 0;"
- "a_corrected = L1;"
- "while(f_iter < fr); a_corrected = a_corrected - 1e-06; M1_11_iter = (k .* s .* Y) ./ (1i .* omega .* tan(k .* a_corrected)); M1_12_iter = (k .* s .* Y) ./ (1i .* omega .* sin(k .* a_corrected)); Z_iter = M1_11_iter - ( (M1_12_iter.^2) ./ (Z_L1 + M1_11_iter) ); B_iter = calcolaMatriceB(G, Z_iter); [Zin_iter, FTT_pzt_iter, ~] = calcolaFunzioniDiTrasferimento(B_iter, Z_iter, Z_iter); FTT_pzt_iter = db2mag(FTT_pzt_iter{1}) .* exp(1j*deg2rad(FTT_pzt_iter{2})); FTT_mass_iter = ( M1_12_iter .* Z_L1 ) ./ ( M1_11_iter.*Z_L1 + M1_11_iter.^2 - M1_12_iter.^2); FTT_iter = FTT_pzt_iter .* FTT_mass_iter; [moduloFTT_iter, faseFTT_iter] = calcolaModuloEFase(FTT_iter, true, true); FTT_iter = {moduloFTT_iter, faseFTT_iter}; [~, index] = max(FTT_iter{1}); f_iter = f(index); end"
